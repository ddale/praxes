
# All globals to which SpecScan will connect need to be created before the
# SpecScan is instantiated. DO NOT USE ASSOCIATIVE ARRAYS TO REPORT DATA!
# They are not broadcast at the time they are set, but polled by SpecClient
# at a later time. This means their values may have changed before SpecClient
# could read them.

def _clientutils_on '{
    global _SC_NEWSCAN _SC_NEWSCANDATA _SC_NEWPLOTDATA _SC_DATA_ACTIVE _SC_PLOT_ACTIVE
    _SC_NEWSCAN = 0

    cdef("user_prescan_head", "_client_setscanenv;", "_clientutils_")
    cdef("user_scan_tail", "_SC_NEWSCAN = 0;", "_clientutils_")
}'


def _clientutils_off '{
    if (_SC_PLOT_ACTIVE == 0 && _SC_DATA_ACTIVE == 0){
        unglobal _SC_NEWSCAN _SC_NEWSCANDATA _SC_DATA_ACTIVE _SC_PLOT_ACTIVE
        cdef("", "", "_clientutils_", "delete")
    }
}'


def _client_setscanenv '{
    local scan_env column_names

    local plot_desc[] scan_desc[] mode_desc[] positions detectors[]
    local npoints spoints id entry attrs

    scan_env = ""

    # Define the original variables for plotting
    plot_desc["type"] = sprintf("\'%s\'", _stype)
    plot_desc["title"] = sprintf("\'Scan %d\'", SCAN_N+1)
    plot_desc["xlabel"] = sprintf("\'%s\'", X_L)
    plot_desc["ylabel"] = sprintf("\'%s\'", cnt_mne(DET))
    plot_desc["nb_motors"] = sprintf("\'%d\'", PLOT_MOTS)
    plot_desc["motor"] = sprintf("\'%s\'", motor_mne(_m[0]))
    plot_desc["counter"] = sprintf("\'%s\'", cnt_mne(DET))

    plot_dict = ""
    for (i in plot_desc) {
        plot_dict = sprintf("%s\'%s\':%s, ", plot_dict, i, plot_desc[i])
    }
    # for backwards compatibility:
    scan_env = sprintf("%s%s", scan_env, plot_dict)
    # and looking forward, the plot information should really be in a subdict:
    scan_env = sprintf("%s\'plot_desc\':{%s}, ", scan_env, plot_dict)

    # collect the scan metadata for phynx:
    npoints = _stype&8? _n1*_n2:_n1
    scan_info["file_name"] = sprintf("\'%s/%s\'", CWD, DATAFILE)
    scan_info["acquisition_command"] = sprintf("\'%s\'", HEADING)
    scan_info["acquisition_id"] = sprintf("%d", SCAN_N+1)
    scan_info["npoints"] = sprintf("%d", npoints)
    if (_stype&8) {
        scan_info["acquisition_shape"] = sprintf("(%d, %d)", _n1, _n2)
    } else {
        scan_info["acquisition_shape"] = sprintf("(%d, )", _n1)
    }

    info_dict = ""
    for (i in scan_info) {
        info_dict = sprintf("%s\'%s\':%s, ", info_dict, i, scan_info[i])
    }
    scan_env = sprintf("%s\'info\':{%s}, ", scan_env, info_dict)

    # create the phynx hierarchy under entry/measurement:
    scan_desc["i"] = sprintf("(\'Dataset\', {\'shape\': (%d,)})", npoints)
    entry = "(\'Signal\', {\'shape\': (%d,), \'signal\': %d})"
    for (i=0;i<COUNTERS;i++) {
        id = sprintf("scalar_data/%s", cnt_mne(i))
        scan_desc[id] = sprintf(entry, npoints, (i==DET))
    }

    if (SKIPMODE_COUNTER) {
        id = "scalar_data/masked"
        entry = "(\'Signal\', {\'shape\': (%d,), \'monitor\': %s, \'threshold\': %d})"
        scan_desc[id] = sprintf(entry, npoints, cnt_mne(SKIPMODE_COUNTER), \
            SKIPMODE_THRESHOLD)
    }

    for (i=0;i<MOTORS;i++) {
        id = sprintf("positioners/%s", motor_mne(i))
        entry = "(\'Dataset\', {\'data\': %g})"
        scan_desc[id] = sprintf("(\'Dataset\', {\'data\': %g})", A[i])
    }
    for (i=0;i<_nm;i++) {
        id = sprintf("scalar_data/%s", motor_mne(i))
        # should add 'primary' also for d3scan, but lets not worry about it now:
        entry = "(\'Axis\', {\'shape\': (%d,), \'axis\': %d, '\range'\: (%g,%g)})"
        scan_desc[id] = sprintf(entry, npoints, _stype&8? i+1:1, _s[i], _f[i])
    }

    if (MCA_CHAN > 0) {
        # this block is executed for old-school MCA description
        local mca_channels mca_cal

        mca_cal = sprintf("(%g,%g,%g)", MCA_DATA_PARAM[0], MCA_DATA_PARAM[1],
            MCA_DATA_PARAM[2])
        entry = "(\'MultiChannelAnalyzer\', {\'shape\': (%d, %d), \'calibration\': %s})"
        scan_desc['mca'] = sprintf(entry, npoints, MCA_CHAN, mca_cal)

        mca_channels = ""
        for(i = 0; i < MCA_CHAN; i++){
            mca_channels = sprintf("%s%g,", mca_channels, MCA_DATA[i][0])
        }
        scan_desc['mca/channels'] = sprintf("(%s)", mca_channels)

        # IMPORTANT: DONT FORGET TO INCLUDE DEADTIME INFORMATION HERE!
    }

    if (EPICS_MCAS > 0) {
        # this block is used for MCAs under EPICS control
        local uch mca_desc mca_channels mca_energy _oo _ss _qq mca_cal

        for (mne in mca_pv) {
            uch = epics_get(sprintf("%s.NUSE", mca_pv[mne]))
            _oo = epics_get(sprintf("%s.CALO", mca_pv[mne]))
            _ss = epics_get(sprintf("%s.CALS", mca_pv[mne]))
            _qq = epics_get(sprintf("%s.CALQ", mca_pv[mne]))

            mca_cal = sprintf("(%g,%g,%g)", _oo, _ss, _qq)
            entry = "(\'MultiChannelAnalyzer\', {\'shape\': (%d, %d), \'calibration\': %s})"
            scan_desc[mne] = sprintf(entry, npoints, MCA_CHAN, mca_cal)

            mca_channels = ""
            for (i = 0; i < uch; i++) {
                mca_channels = sprintf("%s%g,", mca_channels, i)
            }
            scan_desc[sprintf('%s/channels', mne)] = sprintf("(%s)", mca_channels)

            # IMPORTANT: DONT FORGET TO INCLUDE DEADTIME INFORMATION HERE!
        }
    }

    hierarchy_dict = ""
    for (i in scan_desc) {
        info_dict = sprintf("%s\'%s\':%s, ", hierarchy_dict, i, scan_desc[i])
    }
    scan_env = sprintf("%s\'info\':{%s}, ", scan_env, hierarchy_dict)

    _SC_NEWSCAN = sprintf("{%s}", scan_env)
}'


def clientploton '{
    _clientutils_on

    global _SC_OLDX
    _SC_PLOT_ACTIVE = 1

    _SC_OLDX=0

    if (length(plotlist()) == 0)  {
        tty_cntl("md");
        printf("\n- NO COUNTER SELECTED. Run plotselect\n");
        tty_cntl("me")
    }

    cdef("user_scan_plot", "_client_updateplotdata;", "_client_plot_")
}'


def clientplotoff '{
    unglobal _SC_OLDX
    _clientutils_off

    cdef("", "", "_client_plot_", "delete")
}'


def _client_updateplotdata '{
    local x d i n plot_data
    global _SC_OLDX

    n = _stype&8? _g1:NPTS

    x = SCAN_D[n][0]

    if (_stype >= 257) {
        d = 1
    } else {
        d = x - _SC_OLDX
    }

    if (d > 0) {
        _SC_OLDX = x

        plot_data = ""
        plot_data = sprintf("%s\'i\':%d, ", plot_data, NPTS)
        plot_data = sprintf("%s\'x\':%g, ", plot_data, x)

        for (i=PLOT_MOTS; i<(PLOT_CNTRS+PLOT_MOTS); i++) {
            plot_data = sprintf("%s\'%s\':%g, ", plot_data, PLOT_MNE[i], \
                                SCAN_D[n][i])
        }

        _SC_NEWPLOTDATA = sprintf("{%s}", plot_data)
    }
}'


def clientdataon '{
    _clientutils_on

    _SC_DATA_ACTIVE = 1

    cdef("user_scan_loop", "_client_updatescandata;", "_client_data_")
}'


def clientdataoff '{
    _clientutils_off

    cdef("", "", "_client_data_", "delete")
}'


def _client_updatescandata '{
    local i scan_data scalars[] positions[] detectors[]

    scan_data = sprintf("\'i\':%d, ", NPTS)

    for (i=0;i<_nm;i++) {
        positions[motor_mne(_m[i])] = sprintf("%g", A[_m[i]])
    }

    pos_dict = ""
    for (i in positions) {
        pos_dict = sprintf("%s\'%s\':%g, ", pos_dict, i, positions[i])
    }
    scan_data = sprintf("%s\'positions\':{%s}, ", scan_data, pos_dict)

    scalars["epoch"] = sprintf("%f", time())
    for (i=0;i<COUNTERS;i++) {
        scalars[cnt_mne(i)] = sprintf("%g", S[i])
    }

    scalars_dict = ""
    for (i in scalars) {
        scalars_dict = sprintf("%s\'%s\':%g, ", scalars_dict, i, scalars[i])
    }
    scan_data = sprintf("%s\'scalars\':{%s}, ", scan_data, scalars_dict)

    if (MCA_CHAN > 0) {
        local mca_counts detector

        detector = ""

        if (MCA_NAME == "vortex") {
            detector = sprintf("%s\'icr\':%g, ", detector, S[icr])
            detector = sprintf("%s\'ocr\':%g, ", detector, S[ocr])
            detector = sprintf("%s\'real\':%g, ", detector, S[real])
            detector = sprintf("%s\'live\':%g, ", detector, S[live])
            detector = sprintf("%s\'dead\':%g, ", detector, S[dead])
            detector = sprintf("%s\'dtn\':%g, ", detector, S[vtxdtn])
        }

        mca_counts = ""
        for(i = 0; i < MCA_CHAN; i++){
            mca_counts = sprintf("%s%g,", mca_counts, MCA_DATA[i][1])
        }
        detector = sprintf("%s\'counts\':array([%s],dtype=\'i\'), ", \
            detector, mca_counts)

        detectors[MCA_NAME] = detector
    }
    if (EPICS_MCAS > 0) {
        local mca_counts uch detector

        for (mne in mca_pv) {
            detector = ""

            if (USE_DXP) {
                dxpICR = epics_get(sprintf("%s.ICR", dxp_pv[mne]))
                dxpOCR = epics_get(sprintf("%s.OCR", dxp_pv[mne]))
            } else {
                dxpICR = 1
                dxpOCR = 1
            }
            mcaRtime = epics_get(sprintf("%s.ERTM", mca_pv[mne]))
            mcaLtime = epics_get(sprintf("%s.ELTM", mca_pv[mne]))

            mcadtc = dxpICR * mcaRtime
            if (mcadtc != 0) {
                mcadtc = dxpOCR*mcaLtime/mcadtc
            }
            mcaDtime = 100*(1-mcadtc)

            detector = sprintf("%s\'icr\':%g, ", detector, dxpICR)
            detector = sprintf("%s\'ocr\':%g, ", detector, dxpOCR)
            detector = sprintf("%s\'real\':%g, ", detector, mcaRtime)
            detector = sprintf("%s\'live\':%g, ", detector, mcaLtime)
            detector = sprintf("%s\'dead\':%g, ", detector, mcaDtime)
            detector = sprintf("%s\'dtn\':%g, ", detector, mcadtc)

            uch = epics_get(sprintf("%s.NUSE", mca_pv[mne]))
            A_name = sprintf("mcadat_%s",mne)
            mca_counts = ""
            for(i = 0; i < uch; i++){
                mca_counts = sprintf("%s%g,", mca_counts, @A_name[1][i])
            }
            detector = sprintf("%s\'counts\':array([%s],dtype=\'i\'), ", \
                detector, mca_counts)

            detectors[mne] = detector
        }
    }

    dets_dict = ""
    for (mne in detectors) {
        dets_dict = sprintf("%s\'%s\':{%s}, ", dets_dict, mne, detectors[mne])
    }
    scan_data = sprintf("%s%s", scan_data, dets_dict)

    _SC_NEWSCANDATA = sprintf("{%s}", scan_data)
}'
