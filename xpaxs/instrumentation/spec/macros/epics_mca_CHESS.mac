#===============================================================================
#**************SPEC macros for the Advanced Photon Source***********************
#===============================================================================
#
# Beamline/Sector: XOR-Sector4
#                  (easy to be moved to other sectors without change)
#
# Macro Package: Epics MCA controls
#
# Version: 3.4.6
#
# Description: Macros to setup and control multiple epics MCAs, allow users to
#              save mca spectra and the configured MCA ROIS into spec file.
#              requires aalength.mac and uspec_colum.mac( will automatically load )
#
# Written by: Xuesong Jiao
#
# Modified by:
#
# User macros: setup_mca -> interface to configure multiple epics MCAs in spec.
#              setup_mca (no paramerter) -> interactive mode
#              setup_mca mnemonic name PV -> quiet mode
#
#              mcasmode -> turn on mca data collection and save spectra to
#                          device files
#
#              show_mca -> display the configured epics MCAs nicely.
#              mca_rois -> to automatically check the created ROIS in each MCA
#                          and display their parameters.
#              save_rois -> to turn on/off the feature of saving MCA_ROIS(defined
#                           in roi_pv[], and filled when mca_rois is called)
#              rm_mca -> remove one or all configured MCAs,also remove all rois
#                        related to that MCA
#              rm_roi -> remove one/all configured MCA ROIS.Can also rmove all
#                        rois related to one MCA by calling rm_roi mca_nme
#
# Internal macros: mca_on
#                  mca_off
#                  mca_getcounts
#                  mca_scan_loop
#
# Modification history:
#  July 13, 2005 X. Jiao
#  ->Based on macros originally written by P. Jamian, and epics_mca_3.3.mac
#    by J. Lang.
#  Aug. 5, 2005 X. Jiao
#  -> fixed the mca scan output format,separte each mca's spectra
#  -> fixed the cleanup bug
#  -> added user_Fheader(#@ROI entry) to spec scan file if using save_rois on
#  Nov. 22 2005 X. Jiao
#  -> made "save_rois on" to work even if not using MCAscanpt.
#  July,6, 2005 X. Jiao
#  -> added sleep time in wait_mca to make sure it work safely
#  -> enhanced mca_on to enable use psuedo counter
#
#  DAW made some changes to get the ICR and OCR from a digital signal processor (dxp),
# which replaces the realtime and livetime in a few places

#===============================================================================
#
#$Log$
#Revision 1.7  2007/04/04 14:35:24  jiaox
#Fixed bugs introduced in last version.
#
#Revision 1.5  2006/11/02 21:15:22  jiaox
#Now if using monitor count, the mca pseudo counter will get updated correctly.
#
#Revision 1.4  2006/07/06 18:32:28  jiaox
#Added sleep time after data acquisition is done. Made mca_on to enable the  mca roi psuedo counter be updated.
#
#Revision 1.3  2006/06/22 19:21:00  jiaox
#corrected typo
#
#Revision 1.2  2006/05/11 17:46:31  jiaox
#Added CVS Log entry.
#
#
###############################################################################


#===============================================================================
# preload check here
#===============================================================================

if (!(whatis("_aa_length")&0x2)) {
    udo aalength.mac
}

if (!(whatis("u_column_add")&0x2)) {
    udo uspec_column.mac
}

#===============================================================================
# global variables defined here
#===============================================================================

#MCA arrays

global mca_name[] mca_pv[] roi_pv[] dxp_pv[]
global EPICS_MCAS USE_DXP MCA_SCAN

#===============================================================================
# user macros defined here
#===============================================================================

#-------------------------------------------------------------------------------
# setup_mca-> configure epics MCAs and create global arrays for each MCA
#-------------------------------------------------------------------------------

def setup_mca '{
    if ($# == 0) {
        p "Current MCA Setup:\n"
        show_mca
        while(yesno("\nConfigure a new MCA?", "0")) {
            setup_dxp
            local foo nme A_name
            nme = getval("MCA mnemonic:", "")
            if (nme == "") {
                continue
            }
            mca_name[nme] = getval("MCA name:", "")
            mca_pv[nme] = getval("EPICS MCA PV:", "")
            if (USE_DXP) {
                dxp_pv[nme] = getval("EPICS DXP PV:", "")
            }
            foo = epics_par(sprintf("%s.VAL",mca_pv[nme]), "count")
            printf("Found MCA with %i channels\n", foo)
            foo = epics_get(sprintf("%s.NUSE", mca_pv[nme]))
            printf("Reading %i channels of MCA\n", foo)
            A_name = sprintf("mcadat_%s", nme)
            array @A_name[2][foo]
            EPICS_MCAS++
            printf("Created data array %s for MCA %s\n", A_name, nme)
        }
        p "New MCA Setup:"
        show_mca
        if (yesno("\nDo you want to setup the ROIS? \
                \n(You can always use mca_rois to setup later.)", "0")) {
            mca_rois
            printf("\n\nOnce you reconfigure the MCA ROIS externally(i.e. in MEDM),\
                 \nuse mca_rois to refresh, or you may not save the new ROIS.")
        }
    } else {
        local nme A_name foo
        nme = "$1"
        mca_name[nme] = "$2"
        mca_pv[nme] =  "$3"
        foo =  epics_get(sprintf("%s.NUSE", mca_pv[nme]))
        A_name =  sprintf("mcadat_%s", nme)
        array @A_name[2][foo]
        EPICS_MCAS++
        mca_rois
        p "\n"
        show_mca
    }
}'

#-------------------------------------------------------------------------------
# show_mca-> display configured MCAs and their configuration
#-------------------------------------------------------------------------------

def show_mca '{
    if (unset("mca_pv")) {
        global mca_name[] mca_pv[]
    }
    if (_aa_length(mca_pv) == 0) {
        print "No MCA defined."
    } else {
        local tch uch A_name i

        printf("\n%8.8s %15.15s %15.15s %12.12s %12.12s %15.15s ",\
               "Mne", "Name", "EPICS_PV", "Total_Chs", "Use_Chs", "Data_array")

        for (i in mca_pv) {
            tch = epics_par(sprintf("%s.VAL", mca_pv[i]), "count")
            uch = epics_get(sprintf("%s.NUSE", mca_pv[i]))
            A_name = sprintf("mcadat_%s", i)
            printf("\n%8.8s %15.15s %15.15s %12i %12i %15.15s ",\
                i, mca_name[i], mca_pv[i], tch, uch, A_name)
        }
        printf("\n")
    }
}'

#-------------------------------------------------------------------------------
# mca_rois-> read available ROIs from each MCA and store their pvs in roi_pv
#-------------------------------------------------------------------------------

def mca_rois '{
    global MAXROIN
    MAXROIN = 32
    if(_aa_length(mca_pv) == 0) {
        print "No MCA defined. Please define MCA first."
        exit
    }
    for (i in roi_pv) {
        delete roi_pv[i]
    }
    for (i in mca_pv) {
        local rname rlch rhch A_name flag mne

        flag = 0
        printf("\nCurrent configured ROI for %s:", i)
        for(j=0; j<MAXROIN; j++) {
            rname = epics_get(sprintf("%s.R%iNM", mca_pv[i], j))
            rlch = epics_get(sprintf("%s.R%iLO", mca_pv[i], j))
            rhch = epics_get(sprintf("%s.R%iHI", mca_pv[i], j))
            if ((rname != " ") & (rlch != -1)) {
                mne = sprintf("%sR%i", i, j)
                printf("\nmne: %s |pv: %s.R%i  |name:%s  |low: %i  |high: %i",\
                       mne, mca_pv[i], j, rname, rlch, rhch)
                roi_pv[mne] = sprintf("%s.R%i", mca_pv[i], j)
                flag = 1
            }
        }
        if (!flag) {
            print "\nNo ROIS configured!"
        }
    }
}'

#-------------------------------------------------------------------------------
# save_rois-> save_rois on/off to save/not save ROI data in spec file
#-------------------------------------------------------------------------------

def save_rois '{
    if ($# != 1) {
        print "Usage: save_rois on/off"
        exit
    }
    if ("$1" == "on") {
        u_column_clear("mcaroi")

        local n rname cmd i j
        local tmp[]
        local header_str lch hch

        header_str = ""
        if (_aa_length(roi_pv) == 0) {
            p "\nNo roi configured. Please run mca_rois.\n"
            exit
        }
        for (i in roi_pv) {
            rname = epics_get(sprintf("%sNM", roi_pv[i]))
            rname = strjoin(rname, " ")
            rname = sprintf("%s(%s)", rname, i)
            cmd = sprintf("epics_get(\"%s\")", roi_pv[i])
            u_column_add(rname, "%s", cmd, "mcaroi")
            lch = epics_get(sprintf("%sLO", roi_pv[i]))
            hch = epics_get(sprintf("%sHI", roi_pv[i]))
            header_str = sprintf("%s#@ROI  %s %d %d\n", header_str, rname, lch, hch)
            for (j in mca_pv) {
                if ((index(i,j) == 1) && !(tmp[j])) {
                    tmp[j] = mca_pv[j]
                    break
                }
            }
        }

        for (j in tmp) {
            if (USE_DXP) {
                rname = sprintf("ICR%s", j)
                cmd = sprintf("epics_get(\"%s.ICR\")", dxp_pv[j])
                u_column_add(rname, "%.8g", cmd, "mcaroi")
                rname = sprintf("OCR%s", j)
                cmd = sprintf("epics_get(\"%s.OCR\")", dxp_pv[j])
                u_column_add(rname, "%.8g", cmd, "mcaroi")
            } else {
                rname = sprintf("Rt%s", j)
                cmd = sprintf("epics_get(\"%s.ERTM\")", mca_pv[j])
                u_column_add(rname,"%.8g", cmd, "mcaroi")
                rname = sprintf("Lt%s", j)
                cmd = sprintf("epics_get(\"%s.ELTM\")", mca_pv[j])
                u_column_add(rname, "%.8g", cmd, "mcaroi")
            }
        }
        header_str = sprintf("printf(\"%s\");\n", header_str)
        cdef("user_Fheader", header_str, "mcaroi", "0x20")
        print "\n"
        u_column_show
        mca_on
    }
    if ("$1" == "off") {
        u_column_clear("mcaroi")
        cdef("user_Fheader", "", "mcaroi", "delete")
        mca_off
    }
}'

#-------------------------------------------------------------------------------
# rm_mca-> i.e. rm_mca all( clear all configure MCAs)
#               rm_mca mca1( clear MCA with mnemonic name mca1)
#-------------------------------------------------------------------------------

def rm_mca '{
    if ($# != 1) {
        print "Usage: rm_mca mne or rm_mca all.\n"
        exit
    }
    if ("$1" == "all") {
        for (i in mca_pv) {
            rm_roi all
            A_name = sprintf("mcadat_%s",i)
            unglobal @A_name
            delete mca_pv[i] mca_name[i] dxp_pv[i]
            printf("Deleted MCA %s and data array %s\n",i,A_name)
        }
    } else {
        if (mca_pv["$1"] == 0) {
            printf("Invalid MCA mnemonic %s\n","$1")
            exit
        }
        rm_roi "$1"
        A_name = sprintf("mcadat_%s","$1")
        unglobal @A_name
        delete mca_pv["$1"] mca_name["$1"] dxp_pv["$1"]
        printf("Deleted MCA %s and data array %s\n","$1",A_name)
    }
}'

#-------------------------------------------------------------------------------
# rm_roi-> rm_roi mca1R1 ( to delete roi with mnemonic mca1R1)
#          rm_roi mca1  ( to delete all rois related to mca1)
#          rm_roi all   ( to clear all rois)
#-------------------------------------------------------------------------------

def rm_roi '{
    if ($# != 1) {
        print "Usage: rm_roi mne or rm_roi all or rm_roi mca_mne.\n"
        exit
    }
    if ("$1" == "all") {
        for (i in roi_pv) {
            delete roi_pv[i]
            printf("\nDeleted MCA  ROI %s \n",i)
        }
    } else {
        if (mca_pv["$1"]!=0) {
            local foo
            for (i in roi_pv) {
                foo = substr(i,0,length("$1"))
                if(foo == "$1") {
                    delete roi_pv[i]
                    printf("Deleted MCA ROI %s related to %s\n",i,"$1")
                }
            }
        } else {
            if (roi_pv["$1"] == 0) {
                printf("Invalid ROI mnemonic %s\n","$1")
                exit
            }
            delete roi_pv["$1"]
            printf("\nDeleted MCA ROI %s \n", "$1")
        }
    }
}'

#-------------------------------------------------------------------------------
# mcasmode->Set the scan mode for epics interface
#-------------------------------------------------------------------------------

def mcasmode '{
    MCA_SCAN = $1

    if($# < 1) {
        MCA_SCAN = yesno("Enable MCA scan mode", MCA_SCAN)
    }
}'

#===============================================================================
# internal macros defined here
#===============================================================================

def setup_dxp '{
    if (yesno("\nUse a DXP with this MCA?", "0")) {
        USE_DXP = 1
    } else {
        USE_DXP = 0
    }
}'

def mca_on '{
    cdef("user_Fheader", "mca_specfile_Fheader;", "epics_mca", 0x10)
    cdef("user_postscan_head", "mca_set_env;", "epics_mca")
    cdef("user_precount", "mca_startcount;", "epics_mca", 0x20)
    cdef("user_getcounts", "mca_getcounts;", "epics_mca", 0x10)

}'

def mca_off '{
    cdef("", "", "epics_mca", "delete")
}'

def mca_startcount '{
    if (COUNT_TIME != 0) {
        if (COUNT_TIME > 0) {
            for (i in mca_pv) {
                epics_put(sprintf(\"%s.PRTM\", mca_pv[i]), COUNT_TIME)
            }
        } else {
            for (i in mca_pv) {
                epics_put(sprintf(\"%s.PRTM\", mca_pv[i]), 0)
            }
        }
        for (i in mca_pv) {
            epics_put(sprintf(\"%s.ERST\", mca_pv[i]), 1)
        }
    }
}'

global EPICS_OVERHEAD
# This value should be tweaked so monitor counts integrates properly
# need to compare spec's seconds with mca real time
EPICS_OVERHEAD = 0.047

def mca_getcounts '{
    if (COUNT_TIME < 0) {
        sleep(EPICS_OVERHEAD)
        for(i in mca_pv) {
            epics_put(sprintf(\"%s.STOP\",mca_pv[i]), 1)
        }
    }
    for (i in mca_pv) {
        local _oo _ss _qq A_name pvlist[]

        while (epics_get(sprintf("%s.ACQG", mca_pv[i]), "short")) {
            sleep(0.01)
        }
        _oo = epics_get(sprintf("%s.CALO", mca_pv[i]))
        _ss = epics_get(sprintf("%s.CALS", mca_pv[i]))
        _qq = epics_get(sprintf("%s.CALQ", mca_pv[i]))
        A_name = sprintf("mcadat_%s", i)
        array_op("fill", @A_name[0], 1)
        @A_name[0] = _oo + @A_name[0] * (_ss + _qq * @A_name[0])
        @A_name[1] = epics_get(mca_pv[i])
    }
    for (i in dxp_pv) {
        epics_put(sprintf(\"%s.READ_PARAMS\", dxp_pv[i]), 1)
    }

    if (MCA_SCAN) {
        mca_report_counts
    }
}'

#----------------------------------------------------------------------
# Save Data for each point in the same spec file with the proper format
# need to move most print statements to mca_Fheader
#----------------------------------------------------------------------

def mca_report_counts '{
    local device_file

    for(mne in mca_pv ) {
        device_file = get_device_file(mne)
        on(device_file)
        offt

        local mcaRtime mcaLtime dxpICr dxpOCR mcaDtime mcadtc

        if (USE_DXP) {
             dxpICR = epics_get(sprintf("%s.ICR", dxp_pv[mne]))
             dxpOCR = epics_get(sprintf("%s.OCR", dxp_pv[mne]))
        } else {
            dxpICR = 1
            dxpOCR = 1
        }

        mcaRtime = epics_get(sprintf("%s.ERTM", mca_pv[mne]))
        mcaLtime = epics_get(sprintf("%s.ELTM", mca_pv[mne]))

        # dxp realtime does not gate properly, lets try to correct it:
        mcaRtime = mcaRtime > 1.1*S[sec]? S[sec]:mcaRtime

        # lets calculate the first-order deadtime %:
        mcaDtime = dxpICR * mcaRtime
            if (mcaDtime != 0) {
                mcaDtime = 100 * (1 - dxpOCR * mcaLtime / mcaDtime)
            }

        printf("%g %g %g %g %g\n", dxpICR, dxpOCR, mcaRtime, mcaLtime, mcaDtime)

        printf("@%s ", mne)
        A_name=sprintf("mcadat_%s", mne)
        array_dump(@A_name[1], "%25C")

        close(device_file)
        ont

        if (whatis("client_set_data")&0x2) {
            client_set_data(sprintf("%s/counts", mne), @A_name[1])

            if (MCA_NAME == "vortex") {
                client_set_data(sprintf("%s/icr", mne), dxpICR)
                client_set_data(sprintf("%s/ocr", mne), dxpOCR)
                client_set_data(sprintf("%s/real", mne), mcaRtime)
                client_set_data(sprintf("%s/live", mne), mcaLtime)
                client_set_data(sprintf("%s/dead_time", mne), mcaDtime)
            }
        }
    }
}'

#----------------------------------------------------------------------
# Format the Header for a specfile
#----------------------------------------------------------------------

def mca_specfile_Fheader '{
    printf("#U Saving mca spectra for each scan pt\n")
    printf(mca_getcalib())
}'


def mca_set_env '{
    local uch device_file

    for (mne in mca_pv) {
        device_file = get_device_file(mne)

        if (NPTS == 0) {
            constant EPOCH time()
            fprintf(device_file, "#F %s\n", device_file)
            fprintf(device_file, "#E %d\n", EPOCH)
            fprintf(device_file, "#D %s\n", date())
            fprintf(device_file, "#C %s  User= %s\n", TITLE, USER)
        }

        fprintf(device_file, "\n#S %d  %s\n#D %s\n", SCAN_N, HEADING, DATE)

        if(_ctime<0) fprintf(device_file, "#M %g (%s)\n", -_ctime, cnt_name(MON))
        else fprintf(device_file, "#T %g (%s)\n", _ctime, cnt_name(sec))

        uch = epics_get(sprintf("%s.NUSE", mca_pv[mne]))

        _oo = epics_get(sprintf("%s.CALO", mca_pv[mne]))
        _ss = epics_get(sprintf("%s.CALS", mca_pv[mne]))
        _qq = epics_get(sprintf("%s.CALQ", mca_pv[mne]))
        fprintf(device_file, "#U EPICS mca: %s(%s)\n", mne, mca_pv[mne])
        fprintf(device_file, "#@MCA %25C\n")
        fprintf(device_file, "#@CHANN %i 0 %i 1\n", uch, uch-1)
        fprintf(device_file, "#@CALIB %g %g %g \n", _oo, _ss, _qq)
        fprintf(device_file, "#N 5\n")
        fprintf(device_file, "#L icr  ocr  real  live  dead_time\n")

        if (whatis("client_set_scan_env")&0x2) {
            local kwargs[]

            local array cal[3]
            cal[0] = _oo; cal[0] = _oo; cal[0] = _oo
            kwargs["calibration"] = python_repr(python_repr(cal))
            client_set_scan_env(MCA_NAME, "MultiChannelAnalyzer", kwargs)

            for (i in kwargs) delete kwargs[i]
            local array shape[2]
            shape[0] = SC_NPOINTS; shape[1] = uch
            kwargs["shape"] = python_repr(shape)
            kwargs["dtype"] = python_repr("uint32")
            id = sprintf("%s/counts", mne)
            client_set_scan_env(id, "McaSpectrum", kwargs)

            for (i in kwargs) delete kwargs[i]
            local array mca_channels[uch]
            array_op("fill", mca_channels, 1, 1)
            kwargs["data"] = python_repr(mca_channels)
            id = sprintf("%s/channels", mne)
            client_set_scan_env(id, "Dataset", kwargs)

            if (USE_DXP) {
                local units[], type
                local array shape[1]
                shape[0] = SC_NPOINTS

                units["icr"] = "s"
                units["ocr"] = "s"
                units["real"] = "s"
                units["live"] = "s"
                units["dead_time"] = "percent"

                for (dset in units) {
                    for (i in kwargs) delete kwargs[i]
                    kwargs["shape"] = python_repr(shape)
                    kwargs["dtype"] = python_repr("f")
                    kwargs["units"] = python_repr(units[dset])
                    if (dset == "dead_time") {
                        type = "DeadTime"
                        kwargs["dead_time_format"] = python_repr(units[dset])
                    } else {
                        type = "Dataset"
                    }
                    id = sprintf("%s/%s", mne, dset)
                    client_set_scan_env(id, type, kwargs)
                }
            }
        }
    }
}'


def get_device_file(mne) '{
    if (!index(DATAFILE,"/") && file_info(DATA_DIR,"-d")) {
        return(sprintf("%s%s.scan%i.%s.mca", DATA_DIR, DATAFILE, SCAN_N, mne))
    } else {
        return(sprintf("%s.scan%i.%s.mca", DATAFILE, SCAN_N, mne))
    }
}'


def mca_getcalib() '{
    local str
    str = ""
    for (i in mca_pv) {
        _oo = epics_get(sprintf("%s.CALO", mca_pv[i]))
        _ss = epics_get(sprintf("%s.CALS", mca_pv[i]))
        _qq = epics_get(sprintf("%s.CALQ", mca_pv[i]))
        str = sprintf("%s#@CALIB %g %g %g %s \n", str, _oo, _ss, _qq, i)
    }
    return(str)
}'
